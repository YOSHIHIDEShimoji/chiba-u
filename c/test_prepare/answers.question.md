## 目次

- [1章](#1章)
- [2章](#2章)
- [3章](#3章)
- [4章](#4章)
- [5章](#5章)
- [6章](#6章)
- [7章](#7章)
- [8章](#8章)
- [9章](#9章)
- [10章](#10章)
- [11章](#11章)

## 1章
### ホームディレクトリの中（下）にあるディレクトリ PROGRAMに移動する．(カレントディレクトリは不明だとします)

1. cd  ./PROGRAM
2. cd  /PROGRAM
3. cd  を実行後にcd  PROGRAM
4. cd  PROGRAM
5. cd  \~/PROGRAM

**正解: 3, 5**
解説: `cd` 単体でホームディレクトリに移動し，その後 `cd PROGRAM` によって `~/PROGRAM` に移動できます。または直接 `cd ~/PROGRAM` と指定しても同じ場所に移動できます。

---

### カレントディレクトリ PROGRAMにソースプログラム（ファイル名test1.c）を作成するために，ファイル名を指定してviを起動する方法．（起動後は各自で指定プログラムを入力）

1. vi  test1.c
2. vi  ./test1.c
3. VI  test1.c
4. vi
5. vi  PROGRAM/test1.c

**正解: 1, 2**
解説: カレントディレクトリにファイルを作成するには `vi test1.c` または `vi ./test1.c` とします。

---

### test1.cのコピーをtest\_orig.cという名前でカレントディレクトリPROGRAMの下にあるディレクトリoldに作成する．（ディレクトリold はこのコマンドの前に作成されていることを仮定する）

1. cp  test1.c  \~/old/test\_orig.c
2. cp  test1.c  old/test\_orig.c
3. cp  test1.c  ./old/test\_orig.c
4. cp  test1.c  old  test\_orig.c
5. cp  test1.c  /old/test\_orig.c

**正解: 2, 3**
解説: `old` はカレントディレクトリ内のサブディレクトリであるため，相対パス `old/test_orig.c` または `./old/test_orig.c` が適切です。

---

### test.cのprintfのある行を1行から5行に増やす編集をする．vi でファイルを開き，カーソルをprintfの行に移動させた後のコマンドとして正しいものを全て答えてください。

1. ddの後にカーソルを貼り付けたい上の行に移動してからpを5回
2. ddの後にカーソルを貼り付けたい上の行に移動してから5p
3. yyの後にpを4回
4. ddの後にpを4回
5. yyの後に4p

**正解: 1, 2, 3, 5**
解説: `yy` は行コピー，`dd` は行削除です。貼り付けには `p` を使用し，繰り返し回数を数値で前置できます。

---

### 先ほど作成した2つのファイル，test.cとtest\_orig.cの違いをdiffコマンドを利用して表示．（カレントディレクトリはPROGRAM）

1. diff   test1.c   /old/test\_orig.c
2. diff   test1.c   test\_orig.c
3. diff   test1.c   old/test\_orig.c
4. diff   test1.c   old  test\_orig.c
5. diff   test1.c   \~/old/test\_orig.c

**正解: 3**
解説: `old` はPROGRAMディレクトリ内にあるサブディレクトリのため，相対パス `old/test_orig.c` が正しい指定方法です。

---

## 2章
### int型の変数xの変数宣言とともに，int型（4バイト）が表すことができる最大値を初期値として代入する式として正しいものを選択してください。

1. int x = 2147483647
2. int x = 4294967295;
3. int x = 2147483647;
4. int x <- 4294967295;
5. int 2147483647 = x;

**正解: 3**
解説: `int`型の最大値は32ビット符号付き整数で `2147483647`。正しい構文は `int x = 2147483647;` です。

---

### 整数変数xの値を表示する実行文として正しいものを下記の中から選択してください。

1. printf("int型の最大値は%s \n", x);
2. printf("int型の最大値は%d \n", x);
3. printf("int型の最大値は%f \n", x);
4. printf("int型の最大値は%c \n", x);
5. printf("int型の最大値は%u \n", x);

**正解: 2**
解説: `%d` は `int` 型の値を表示するフォーマット指定子で、変数 `x` の値を正しく出力できます。

---

### unsigned int型の最大値（ここではU）とint型の最大値（ここではI）の関係として正しいものを選択してください。

1. UはIを2倍して1引いた値と等しい。
2. IはUを2倍した値と等しい。
3. UはIを2倍した値と等しい。
4. UはIを2倍して1加えた値と等しい。
5. UとIは等しい。

**正解: 4**
解説: `int`型の最大値は `2^31 - 1 = 2147483647`、`unsigned int`型の最大値は `2^32 - 1 = 4294967295`。
したがって、 `U = I * 2 + 1` です。

### 実数変数xの変数宣言として正しいものを選択してください。

1. double x　
2. int x;
3. float x;　
4. double x;　
5. char x;
6. unsigned int x;

**正解: 3, 4**
解説: 実数（小数）を扱うには `float` または `double` 型を使います。

---

### 6.0を実数変数xで割った結果を画面表示する実行文として正しいものを選択してください。

1. printf("6.0/%f=%f \n", 6.0/x, x);　
2. printf("6.0/%f=%f \n", x, 6.0/x);　
3. printf("6.0/%d=%d \n", x, 6.0/x);　
4. print("6.0/%d=%d \n", 6.0/x, x);　
5. print("6.0/%f=%f \n", x, 6.0/x);　

**正解: 2**
解説: `printf` による浮動小数点の出力は `%f` を使います。順番にも注意が必要です。

---

### char型の変数cを初期値127で宣言した後，printf("cは%d \n", c);の実行により表示される値を下記の中から選択してください。

1. 0　
2. 127　
3. -128　
4. 128　
5. -1　

**正解: 2**
解説: `char` 型は符号付き8ビット整数（-128～127）であり、127はそのまま出力されます。

---

### char型の変数cを初期値127で宣言した後, cに1を加えました．printf("cは%d \n", c);の実行により表示される値を下記の中から選択してください。

1. -128　
2. 128　
3. 0　
4. -1　
5. 127　

**正解: 1**
解説: `char` 型の最大値127に1を加えるとオーバーフローして最小値 -128 に戻ります（2の補数表現）。

---

### 8進数の100と16進数の100がそれぞれ10進数でいくつになるか正しい組み合わせを以下から選んでください。

1. 16と48
2. 64と256　
3. 64と128
4. 32と128　
5. 100と100

**正解: 2**
解説: `0100`（8進数）は64、`0x100`（16進数）は256になります。

---

### 3章
### 実数変数xの変数宣言として正しいものを選択してください。

1. double x　
2. int x;
3. float x;　
4. double x;　
5. char x;
6. unsigned int x;

**正解: 3, 4**
解説: 実数（小数）を扱うには `float` または `double` 型を使います。

---

### 6.0を実数変数xで割った結果を画面表示する実行文として正しいものを選択してください。

1. printf("6.0/%f=%f \n", 6.0/x, x);　
2. printf("6.0/%f=%f \n", x, 6.0/x);　
3. printf("6.0/%d=%d \n", x, 6.0/x);　
4. print("6.0/%d=%d \n", 6.0/x, x);　
5. print("6.0/%f=%f \n", x, 6.0/x);　

**正解: 2**
解説: `printf` による浮動小数点の出力は `%f` を使います。順番にも注意が必要です。

---

### char型の変数cを初期値127で宣言した後，printf("cは%d \n", c);の実行により表示される値を下記の中から選択してください。

1. 0　
2. 127　
3. -128　
4. 128　
5. -1　

**正解: 2**
解説: `char` 型は符号付き8ビット整数（-128～127）であり、127はそのまま出力されます。

---

### char型の変数cを初期値127で宣言した後, cに1を加えました．printf("cは%d \n", c);の実行により表示される値を下記の中から選択してください。

1. -128　
2. 128　
3. 0　
4. -1　
5. 127　

**正解: 1**
解説: `char` 型の最大値127に1を加えるとオーバーフローして最小値 -128 に戻ります（2の補数表現）。

---

### 8進数の100と16進数の100がそれぞれ10進数でいくつになるか正しい組み合わせを以下から選んでください。

1. 16と48
2. 64と256　
3. 64と128
4. 32と128　
5. 100と100

**正解: 2**
解説: `0100`（8進数）は64、`0x100`（16進数）は256になります。

---

## 3章
### 整数値300を保存するために最小限のメモリ領域でよい型は以下のうちのどれか，適切なものを選択してください。

1. int
2. char　
3. float
4. short int
5. unsigned char

**正解: 4**
解説: `short int` は通常16ビットで、300はその範囲内（-32768〜32767）に収まるため最小限のサイズです。

---

### 配列名がaのchar型の配列を32,64,128で初期化する文と、配列を利用して64と表示させる文の組み合わせとして正しいものを選択してください。

1. char a\[ ] = {32,64,128}; と printf("%d\n", a\[1]);
2. char a\[ ] = (32,64,128); と printf("%d\n", a\[1]);
3. char a\[ ] = {32,64,128}; と printf("%d\n", a\[0]);
4. char a\[ ] = {32,64,128}; と printf("%d\n", a\[2]);
5. char a\[ ] = (32,64,128); と printf("%d\n", a\[0]);

**正解: 1**
解説: 配列初期化は `{}` を使います。64はインデックス1にある値なので `a[1]` で出力します。

---

### 文字配列（配列名：name）を宣言し、Chibaの後ろに?（クエスチョンマーク）を付けた文字列を「データ型 配列名\[ ] = {定数,・・・, 定数};」の形式で初期値設定する文として正しいものを選択してください。

1. char name\[ ] = {'C', 'h', 'i', 'b', 'a', '?', '\n'};
2. char name\[ ] = {'C', 'h', 'i', 'b', 'a', '?', '\0'};
3. char name\[ ] = {'C', 'h', 'i', 'b', 'a', '?', '\0'};
4. char name\[ ] = {'C', 'h', 'i', 'b', 'a', '?'};
5. char name\[ ] = {'C', 'h', 'i', 'b', 'a', '?'};

**正解: 2**
解説: `\?` はクエスチョンマークのエスケープ、`\0` は文字列終端を意味します。

---

### 文字配列（配列名：name）を宣言し、文字列 Chiba Univ. を初期値設定する文として正しいものを選択してください（ChibaとUnivの間はタブ文字のエスケープシーケンスを利用）。

1. char name\[ ] = Chiba\tUniv.;
2. char name\[ ] = "Chiba\0Univ.";
3. char name\[ ] = "Chiba\aUniv.";
4. char name\[ ] = "Chiba\tUniv.";
5. char name\[ ] = 'Chiba\tUniv.';

**正解: 4**
解説: 文字列リテラルは `"..."` で囲み、タブ文字は `\t` で表します。

---

### 文字配列（配列名：name）に保存されている文字列 Chiba Univ. を画面表示させる文として正しいものを選択してください。

1. printf("%c\n", name\[10]);
2. printf("%s\n", name\[11]);
3. printf("%c\n", name);
4. printf("%s\n", name\[12]);
5. printf("%s\n", name);

**正解: 5**
解説: `printf("%s", name);` は文字列全体を表示する標準的な方法です。

---

## 4章
### while文の条件式として，iが30以下の時に真，31以上の時に偽になる式を選択してください。

1. i < 31
2. i => 30
3. i <= 30
4. i =< 30
5. i >= 30

**正解: 1, 3**
解説: `i < 31` または `i <= 30` はどちらも i が30以下のときに真となります。

---

### char型の変数cが大文字A-Zの範囲であるときに真，範囲外の時に偽になる条件式を選択してください。

1. 'A' <= c <= 'Z'
2. 'A' =< c && c <= 'Z'
3. c >= 'A' && c <= 'Z'
4. c => 'A' && c <= 'Z'
5. 'A' <= c && c <= 'Z'

**正解: 3, 5**
解説: 論理演算は2項ずつ行う必要があります。正しい形式は `'A' <= c && c <= 'Z'` または `c >= 'A' && c <= 'Z'` です。

---

### 2から1万まで表示するwhile文として適切なものを選択してください。

1. int n = 1; while (n <= 10000) printf("%d\n", n++);
2. int n = 1; while (n++ <= 10000) printf("%d\n", n);
3. int n = 2; while (n <= 10000) printf("%d\n", n++);
4. int n = 1; while (++n <= 10000) printf("%d\n", n);
5. int n = 2; while (n++ <= 10000) printf("%d\n", n);

**正解: 3, 4**
解説: `int n = 2; while (n <= 10000)` と `int n = 1; while (++n <= 10000)` はどちらも2から開始して1万まで表示するロジックになります。

---

### nがiで割り切れたらiを画面表示する条件判定文として適切なものを選択してください。

1. if (n / i == 0) printf("%d", i);
2. if (n % i = 0) printf("%d", i);
3. if (i / n == 0) printf("%d", i);
4. if (i % n == 0) printf("%d", i);
5. if (n % i == 0) printf("%d", i);

**正解: 5**
解説: `n % i == 0` は n が i で割り切れる条件式です。

---

## 5章
### 3, 4, 5 のいずれを入力しても Spring を出力する switch 文の文法として正しいものを選択しなさい。

```c
// 1. 
switch (m) {
   　　case 3:　4:　5:　printf("Spring\n"); break;
   　}
```
```c
// 2. 
switch (m) {
   　　case 3:　printf("Spring\n");
   　　case 4:　printf("Spring\n");
   　　case 5:　printf("Spring\n"); break;
   　}
```
```c 
// 3. 
switch (m) {
   　　case 3,　4,　5:　printf("Spring\n"); break;
   　}
```
```c
// 4. 
switch (m) {
   　　case 3:　
   　　case 4:　
   　　case 5:　printf("Spring\n"); break;
   　}
```
```c
// 5. 
switch (m) {
   　　case 3 to 5:　printf("Spring\n"); break;
   　}
```

**正解: 4**
解説: C言語の `switch` 文では、複数の `case` に対して処理をまとめるには `case 3: case 4: case 5:` のように連続して記述し、最後に実行したい処理を記述します。

--- 

## 6章
### 要素数80の文字配列sにキーボードから入力した文字列を保存するプログラムとして正しいものを選択してください。

1. s = gets();
2. gets(s\[80]);
3. gets(s, 80);
4. gets(s);
5. getc(s);

**正解: 4**
解説: `gets(s);` はC言語で文字配列`s`に標準入力から文字列を読み込む関数呼び出しとして正しい構文です（ただし、セキュリティ上の理由で現代では非推奨）。

---

### char s1\[80], s2\[80];で定義された２つの文字配列に保存された文字列を改行せずに連続して画面に表示する方法として正しいものを選択してください。

1. printf("%s%\ns\n", s1, s2);
2. printf("%s%s\n", s1, s2);
3. puts(s1); puts(s2);
4. puts(s1);puts(s2);
5. puts(s1, s2);

**正解: 2**
解説: `printf("%s%s\n", s1, s2);` は2つの文字列を連結して改行付きで出力する正しい方法です。

---

### キーボードからEOFが入力されるまで，繰り返し整数変数nに整数値を入力するwhile文として正しいものを選択してください。

1. while(scanf("%ｆ", n) != EOF )
2. while(scanf("%ｆ", \&n) != EOF )
3. while(scanf("%d", \&n) != EOF )
4. while(printf("%d", n) != EOF )
5. while(scanf("%d", n) != EOF )

**正解: 3**
解説: `scanf("%d", &n)` は整数の入力を正しく受け取る構文で、EOF検出までループさせる条件として適切です。

---

### キーボードから入力した文字が変数nに保存されたとして，「表示する文字コードが10進数で32 – 126の範囲以外を含む場合，画面表示しないようにする」ための条件判定として適したものを選んでください。

1. if ( 32 <= n && n < 117)
2. if ( 32 <= n && n < 116)
3. if ( 32 <= n && n <= 126)
4. if ( 32 <= n && n <= 117)
5. if ( 32 <= n && n < 118)

**正解: 4, 5**
解説: `if (32 <= n && n <= 117)` と `if (32 <= n && n < 118)` はいずれも文字コードが32以上118未満の範囲で制限されており、条件として適切です。

---

### 入力した文字nから文字コード順に10文字分を繰り返し5回表示するfor文として適したものを選んでください（iとjは整数変数）。

```c
// 1. 
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", n++);
}
```
```c
// 2.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", ++n);
　　n -= 10;
}
```
```c
// 3.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", ++n);
　　n += 10;
}
```
```c
// 4.
for(i=1; i <=10; i++) {
　　for(j=1; j <= 5; j++)
　　　　printf("%c", n++);
　　n -= 5;
}
```
```c
// 5.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", n++);
　　n -= 10;
}
```

**正解: 5**
解説: 各回で10文字を出力し、次のループのために`n`を元に戻す構文として `n -= 10;` を含む5番のコードが正しいです。

### 関数 warikan のプロトタイプ宣言として適したものを選んでください。

1. double warikan(int a, int b, int c);
2. double warikan(int a, int b, int c)
3. double warikan(int a, b, c);
4. double warikan(int, int, int);
5. int warikan(int a, int b, int c);

**正解: 1, 4**
解説: プロトタイプ宣言にはセミコロンが必要です。また、仮引数の型だけでも構いません。

---

### 戻り値が実数で、3つの整数を実引数とする関数 warikan を呼び出す方法として適したものを選んでください（変数 a, b, c は整数とする）。

1. double warikan(int a, int b, int c);
2. warikan(int 30, int 5, int 50049);
3. warikan(a, b, c);
4. warikan(int a, int b, int c);
5. warikan(30, 5, 50049);

**正解: 3, 5**
解説: 関数呼び出し時には型を書きません。正しくは `warikan(a, b, c)` や `warikan(30, 5, 50049)` の形式です。

---

### 2つの整数値を仮引数とする関数 min\_int() の定義として正しいものを選択してください。

1. int min\_int(int x, int y) { if (x < y) return x; elseif return y; }
2. int min\_int(int x, int y) { if (x < y) return x; else return y; }
3. int min\_int(int x, int y) { if (x < y) return x; return y; }
4. int min\_int(int x, int y) { if (x <= y) return x; else return y; }
5. int min\_int(int x, int y) { if (x > y) return x; else return y; }

**正解: 2, 3, 4**
解説: `elseif` は C 言語の構文にはなく、`else if` が正しい形式です。条件に応じて `return` を返す正しい構文が求められます。

---

## 7章
### 下記プログラムの最初に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=11, b=10
2. a=13, b=10
3. a=11, b=8
4. a=12, b=11
5. a=9, b=8

**正解: 1**
解説: `a++`と`b++`は後置インクリメントで、表示時点ではそれぞれ11と10が表示されます。

---

### 下記プログラムの2番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=12, b=11
2. a=13, b=10
3. a=11, b=8
4. a=9, b=8
5. a=11, b=10

**正解: 4**
解説: `func()`内ではローカル変数`a = 9`とし、`b = 9`。その後`a++`と`--b`を評価して出力されるのは `a=9, b=8`。

---

### 下記プログラムの3番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=11, b=10
2. a=12, b=11
3. a=13, b=10
4. a=9, b=8
5. a=11, b=8

**正解: 5**
解説: `a`はmain内のローカル変数で`a++`後に12、`--a`で11に戻る。`b`はグローバル変数で`b++`後に11、`func()`内で--されて8に。

---

### 下記プログラムの最初に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void m(int n);
int main(void)
{    m(-10);
     m(-5);
     return 0;
}
void m(int n)
{    static int c = 0;
     if(n < c) c = n;
     printf("%d\n", c);
}
```

1. -5
2. -15
3. 0
4. 10
5. -10

**正解: 5**
解説: 初期値0の`static int c`に対し、最初の`n = -10`は `c` より小さいので `c = -10` となる。

---

### 下記プログラムの2番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void m(int n);
int main(void)
{    m(-10);
     m(-5);
     return 0;
}
void m(int n)
{    static int c = 0;
     if(n < c) c = n;
     printf("%d\n", c);
}
```

1. 10
2. -10
3. -15
4. 0
5. -5

**正解: 2**
解説: `static`変数`c`は前の呼び出しで `-10` に更新され、`-5` はそれ以上ではないため `c` の値は変わらず `-10` のまま。

## 8章
### 実引数が「文字配列の名前（配列の先頭アドレス）」だけで，戻り値が無い関数のプロトタイプ宣言として正しいものを選択してください。

1. func( char nn\[ 10 ] );
2. void func( char nn\[ ] )
3. void func( char nn )
4. void func( char nn\[ ] );
5. void func( char nn );

**正解: 4**
解説: プロトタイプ宣言として正しい形式は `void func(char nn[]);` であり、戻り値は `void` で、引数は先頭アドレスを意味する文字配列です。

---

### 実引数を「配列の先頭アドレス」とする関数func()の利用例として正しいものを選択してください。ただし，関数の利用前に以下の変数と配列の宣言があるとする。

```c
char c = '0', s[10] = {c, '\0'};
```

1. func( c );
2. func( s\[1] );
3. func( s\[0] );
4. func( s\[10] );
5. func( s );

**正解: 5**
解説: `func(char[])` のような関数に渡す場合、配列変数 `s` は先頭アドレスとして評価されるため `func(s);` が正解です。

---
### 実引数を「int型の配列の先頭アドレスと配列の要素数」とし，戻り値が無い関数関数 rev\_array のプロトタイプ宣言として正しいものを選んでください。

1. int rev\_array ( int v\[ ], int n );
2. void rev\_array ( int v\[ ], int n );
3. void rev\_array ( int v\[ ], n );
4. rev\_array ( int v\[ ], n );
5. rev\_array ( int v\[ ], int n );

**正解: 2**
解説: プロトタイプ宣言では戻り値の型と、すべての引数の型を指定し、セミコロンで終える必要があります。

---

### 実引数を「int型の配列の先頭アドレスと配列の要素数」とする関数 rev\_array の利用例として正しいものを選んでください（配列の宣言：`int v[5] = {12, 23, 34, 45, 56};`）。

1. rev\_array( v\[0], 5);
2. rev\_array ( int v\[ ], 5 );
3. rev\_array( v, 5);
4. rev\_array ( int v\[ ], int 5 );
5. rev\_array ( v\[ ], 5 );

**正解: 3**
解説: 関数呼び出し時は、型を指定せず、配列名と要素数を渡す形です（`rev_array(v, 5);`）。


## 9章
### ポインタの初期化として①適切なものを選んでください。

宣言: `int num1; int *ptr1 = ①num1;`

1. 文字や記号の必要なし
2. &
3. *
4. !
5. (int)

**正解: 2**
解説: `int *ptr1 = &num1;` のように、ポインタには変数のアドレス（&）を代入します。

---

### ポインタと配列の比較に関する評価として正しいものを選んでください。

宣言: `int x=3, ary[3] ={1,3,6};`

1. x == ary\[1]
2. x == \*ary+1
3. *(ary+*(ary+1)-1) == x+3
4. x == \*(ary+1)
5. *(ary+*(ary+1)-1) == x-2

**正解: 1, 3, 4**
解説: 配列の添字アクセスやポインタ演算の結果を比較する問題です。正しい式を理解するためには、配列の中身やポインタの仕組みを押さえておきましょう。

---

### ポインタの操作と比較に関する評価として正しいものを選んでください。

宣言: `int x=3, ary[3] ={1,3,6}, *ptr1=&x, *ptr2=ary;`

1. *(ary+*++ptr2-1) == x+3
2. \*ptr1 == \*(ptr2+1)
3. ++\*ptr1==4
4. \*ptr1 == ary\[1]
5. \*ptr1 == \*ary+1

**正解: 1, 2, 3, 4**
解説: ポインタのインクリメントや配列へのポインタアクセスを正確に理解することで、比較結果の正誤が判断できます。

## 10章
### int ary\[6] = {1,2,3,101,102,103};として宣言した配列aryの基底アドレスが100であったときに，printf("%u", \&ary\[1]);の実行により画面に表示される値として正しいものを選択しなさい。

1. 104
2. 103
3. 101
4. 1
5. 4

**正解: 1**
解説: `&ary[1]` は `ary[0]` の次の要素のアドレスを意味します。`int` は4バイトなので、`100 + 4 = 104` となります。

---

### 配列int a\[6]の要素番号4の値を表すものを選択しなさい。

1. \*(\&a\[3]+1)
2. a\[4]
3. \*a+4
4. \*(a+4)
5. a+4

**正解: 1, 2, 4**
解説: `a[4]` は直接的な指定、`*(a+4)` はポインタとしての演算、`*(&a[3]+1)` はアドレス計算を用いた間接参照。いずれも同じ要素 `a[4]` を指します。

## 12章
### int型の変数x, yで構成される構造体xydataの記述として正しいものを選択しなさい。

1. struct {
   int x; int y;
   } xydata;
2. struct xydata {
   int x, y;
   };
3. struct xydata {
   int x; int y;
   };
4. struct xydata {
   int x, y;
   }
5. struct xydata {
   int x; int y;
   }

**正解: 2, 3**
解説: 構造体定義の正しい形式は `struct xydata { int x; int y; };` または `int x, y;` のように変数をカンマで区切って定義しても構いません。末尾にセミコロンが必要です。

---

### 4π/3 の計算をPI4o3という名前でマクロ定義したい。記述として正しいものを選択しなさい。ただし，プログラムの先頭に#include の記述があるものとする。

1. \#include PI4o3 M\_PI\*4.0/3.0
2. \#define PI4o3 M\_PI\*4.0/3.0
3. \#define PI4o3 (4/3\*M\_PI)
4. \#define PI4o3 (M\_PI\*4.0/3.0)
5. \#define PI4o3 4/3\*M\_PI

**正解: 4**
解説: マクロ定義では演算順を明確にするため括弧を使用するのが推奨されます。浮動小数点で正確に計算するには `4.0/3.0` を使い、`(M_PI*4.0/3.0)` が正しい形式です。

---

### n³の計算をCUBE(n)という名前でマクロ定義したい。記述として正しいものを選択しなさい。

1. \#define CUBE(n) n*n*n
2. \#define CUBE(n) (n)*(n)*(n)
3. \#define CUBE(n) ((n)*(n)*(n))
4. \#define CUBE(n) n^3
5. \#define CUBE(n) (n*n*n)

**正解: 3**
解説: マクロ展開時に副作用を防ぐためには引数全体を括弧で囲うことが重要です。`((n)*(n)*(n))` が正しい安全な形式です。

---

### ベクトル（2次元，整数型）を表す構造体の記述として正しいものを選んでください。

1. struct vector { int x, y; }
2. union vector { int x; int y; }
3. struct vector { int x, y; };
4. struct vector { int x; int y; };
5. union vector { int x, y; };

**正解: 3, 4**
解説: 構造体宣言にはセミコロンが必要であり、union は2つの値を同時に保持できないため不適切です。

---

### ベクトルの長さを2倍にする関数 v\_2bai の記述として正しいものを選んでください。

1. vector v\_2bai(vector n) { n.x \*= 2; n.y \*= 2; return n; }
2. struct vector v\_2bai(struct vector n) { struct vector temp; temp.x = n.x \* 2; temp.y = n.y \* 2; return temp; }
3. struct vector v\_2bai(struct vector n) { return n\*2; }
4. vector v\_2bai(vector n) { vector temp; temp.x = n.x \* 2; temp.y = n.y \* 2; return temp; }
5. struct vector v\_2bai(struct vector n) { n.x \*= 2; n.y \*= 2; return n; }

**正解: 2, 5**
解説: 関数では構造体の引数を受け取り、各成分を2倍にして戻す処理が必要です。型名に `struct` を明記する必要があります。

---

### 構造体のポインタを利用して、Hiroshi さんのパートナーの子供の名前を取得する式として正しいものを選んでください。

構造体定義：

```c
struct person {
  char name[10];
  struct person *partner;
  struct person *child;
} p0={"Taro", NULL, NULL}, p1={"Hanako", NULL, &p0}, p2={"Hiroshi", &p1, &p0};
```

1. p2->partner->child->name
2. p2.partner.child.name
3. p2.partner.child->name
4. p2.partner->child.name
5. p2.partner->child->name

**正解: 5**
解説: 構造体のポインタを多段でたどる際には `->` を使用します。p2 のパートナー（p1）の子供（p0）の名前へアクセスするためには `p2.partner->child->name` が正解です。
