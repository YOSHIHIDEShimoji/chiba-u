## 目次

- [1章](#1章)
- [2章](#2章)
- [3章](#3章)
- [4章](#4章)
- [5章](#5章)
- [6章](#6章)
- [7章](#7章)
- [8章](#8章)
- [9章](#9章)
- [10章](#10章)
- [11章](#11章)

## 2章
### int型の変数xの変数宣言とともに，int型（4バイト）が表すことができる最大値を初期値として代入する式として正しいものを選択してください。

1. int x = 2147483647
2. int x = 4294967295;
3. int x = 2147483647;
4. int x <- 4294967295;
5. int 2147483647 = x;

**正解: 3**
解説: `int`型の最大値は32ビット符号付き整数で `2147483647`。正しい構文は `int x = 2147483647;` です。

---

### 整数変数xの値を表示する実行文として正しいものを下記の中から選択してください。

1. printf("int型の最大値は%s \n", x);
2. printf("int型の最大値は%d \n", x);
3. printf("int型の最大値は%f \n", x);
4. printf("int型の最大値は%c \n", x);
5. printf("int型の最大値は%u \n", x);

**正解: 2**
解説: `%d` は `int` 型の値を表示するフォーマット指定子で、変数 `x` の値を正しく出力できます。

---

### unsigned int型の最大値（ここではU）とint型の最大値（ここではI）の関係として正しいものを選択してください。

1. UはIを2倍して1引いた値と等しい。
2. IはUを2倍した値と等しい。
3. UはIを2倍した値と等しい。
4. UはIを2倍して1加えた値と等しい。
5. UとIは等しい。

**正解: 4**
解説: `int`型の最大値は `2^31 - 1 = 2147483647`、`unsigned int`型の最大値は `2^32 - 1 = 4294967295`。
したがって、 `U = I * 2 + 1` です。

## 4章
### 演算子として正しいものを以下のなから選択してください。

1. !=
2. \=>
3. >
4. <=
5. \=!
6. \==
7. <

**正解: 1, 3, 4, 6, 7**
解説: 正しい演算子は `!=`, `>`, `<=`, `==`, `<` の5つです。`=>` や `=!` はC言語の演算子として正しくありません。

---

### int a = 1, b = 2; のとき a / b の値として適切なものを以下のなから選択してください。

1. 1.0
2. 1
3. 0
4. 0.0
5. 0.5

**正解: 3**
解説: `a` と `b` はともに `int` 型であるため、`a / b` は整数の除算となり、小数点以下は切り捨てられて `0` になります。

## 6章
### 要素数80の文字配列sにキーボードから入力した文字列を保存するプログラムとして正しいものを選択してください。

1. s = gets();
2. gets(s\[80]);
3. gets(s, 80);
4. gets(s);
5. getc(s);

**正解: 4**
解説: `gets(s);` はC言語で文字配列`s`に標準入力から文字列を読み込む関数呼び出しとして正しい構文です（ただし、セキュリティ上の理由で現代では非推奨）。

---

### char s1\[80], s2\[80];で定義された２つの文字配列に保存された文字列を改行せずに連続して画面に表示する方法として正しいものを選択してください。

1. printf("%s%\ns\n", s1, s2);
2. printf("%s%s\n", s1, s2);
3. puts(s1); puts(s2);
4. puts(s1);puts(s2);
5. puts(s1, s2);

**正解: 2**
解説: `printf("%s%s\n", s1, s2);` は2つの文字列を連結して改行付きで出力する正しい方法です。

---

### キーボードからEOFが入力されるまで，繰り返し整数変数nに整数値を入力するwhile文として正しいものを選択してください。

1. while(scanf("%ｆ", n) != EOF )
2. while(scanf("%ｆ", \&n) != EOF )
3. while(scanf("%d", \&n) != EOF )
4. while(printf("%d", n) != EOF )
5. while(scanf("%d", n) != EOF )

**正解: 3**
解説: `scanf("%d", &n)` は整数の入力を正しく受け取る構文で、EOF検出までループさせる条件として適切です。

---

### キーボードから入力した文字が変数nに保存されたとして，「表示する文字コードが10進数で32 – 126の範囲以外を含む場合，画面表示しないようにする」ための条件判定として適したものを選んでください。

1. if ( 32 <= n && n < 117)
2. if ( 32 <= n && n < 116)
3. if ( 32 <= n && n <= 126)
4. if ( 32 <= n && n <= 117)
5. if ( 32 <= n && n < 118)

**正解: 4, 5**
解説: `if (32 <= n && n <= 117)` と `if (32 <= n && n < 118)` はいずれも文字コードが32以上118未満の範囲で制限されており、条件として適切です。

---

### 入力した文字nから文字コード順に10文字分を繰り返し5回表示するfor文として適したものを選んでください（iとjは整数変数）。

```c
// 1. 
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", n++);
}
```
```c
// 2.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", ++n);
　　n -= 10;
}
```
```c
// 3.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", ++n);
　　n += 10;
}
```
```c
// 4.
for(i=1; i <=10; i++) {
　　for(j=1; j <= 5; j++)
　　　　printf("%c", n++);
　　n -= 5;
}
```
```c
// 5.
for(i=1; i <=5; i++) {
　　for(j=1; j <= 10; j++)
　　　　printf("%c", n++);
　　n -= 10;
}
```

**正解: 5**
解説: 各回で10文字を出力し、次のループのために`n`を元に戻す構文として `n -= 10;` を含む5番のコードが正しいです。

## 7章
### 下記プログラムの最初に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=11, b=10
2. a=13, b=10
3. a=11, b=8
4. a=12, b=11
5. a=9, b=8

**正解: 1**
解説: `a++`と`b++`は後置インクリメントで、表示時点ではそれぞれ11と10が表示されます。

---

### 下記プログラムの2番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=12, b=11
2. a=13, b=10
3. a=11, b=8
4. a=9, b=8
5. a=11, b=10

**正解: 4**
解説: `func()`内ではローカル変数`a = 9`とし、`b = 9`。その後`a++`と`--b`を評価して出力されるのは `a=9, b=8`。

---

### 下記プログラムの3番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void func(void);
int a = 10;
int b = 10;
int main(void)
{    int a = 11;
     printf("a=%d, b=%d\n", a++, b++);
     func();
     printf("a=%d, b=%d\n", --a, b--);
     return 0;
}
void func(void)
{     int a;
     a = 9;
     b = 9;
     printf("a=%d, b=%d\n", a++, --b);
}
```

1. a=11, b=10
2. a=12, b=11
3. a=13, b=10
4. a=9, b=8
5. a=11, b=8

**正解: 5**
解説: `a`はmain内のローカル変数で`a++`後に12、`--a`で11に戻る。`b`はグローバル変数で`b++`後に11、`func()`内で--されて8に。

---

### 下記プログラムの最初に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void m(int n);
int main(void)
{    m(-10);
     m(-5);
     return 0;
}
void m(int n)
{    static int c = 0;
     if(n < c) c = n;
     printf("%d\n", c);
}
```

1. -5
2. -15
3. 0
4. 10
5. -10

**正解: 5**
解説: 初期値0の`static int c`に対し、最初の`n = -10`は `c` より小さいので `c = -10` となる。

---

### 下記プログラムの2番目に実行されるprintf関数で表示される結果として正しいものを選択してください。

```c
void m(int n);
int main(void)
{    m(-10);
     m(-5);
     return 0;
}
void m(int n)
{    static int c = 0;
     if(n < c) c = n;
     printf("%d\n", c);
}
```

1. 10
2. -10
3. -15
4. 0
5. -5

**正解: 2**
解説: `static`変数`c`は前の呼び出しで `-10` に更新され、`-5` はそれ以上ではないため `c` の値は変わらず `-10` のまま。

## 8章
### 実引数が「文字配列の名前（配列の先頭アドレス）」だけで，戻り値が無い関数のプロトタイプ宣言として正しいものを選択してください。

1. func( char nn\[ 10 ] );
2. void func( char nn\[ ] )
3. void func( char nn )
4. void func( char nn\[ ] );
5. void func( char nn );

**正解: 4**
解説: プロトタイプ宣言として正しい形式は `void func(char nn[]);` であり、戻り値は `void` で、引数は先頭アドレスを意味する文字配列です。

---

### 実引数を「配列の先頭アドレス」とする関数func()の利用例として正しいものを選択してください。ただし，関数の利用前に以下の変数と配列の宣言があるとする。

```c
char c = '0', s[10] = {c, '\0'};
```

1. func( c );
2. func( s\[1] );
3. func( s\[0] );
4. func( s\[10] );
5. func( s );

**正解: 5**
解説: `func(char[])` のような関数に渡す場合、配列変数 `s` は先頭アドレスとして評価されるため `func(s);` が正解です。

## 9章
### 実引数が「文字配列の名前（配列の先頭アドレス）」だけで，戻り値が無い関数のプロトタイプ宣言として正しいものを選択してください。

1. func( char nn\[ 10 ] );
2. void func( char nn\[ ] )
3. void func( char nn )
4. void func( char nn\[ ] );
5. void func( char nn );

**正解: 4**
解説: プロトタイプ宣言として正しい形式は `void func(char nn[]);` であり、戻り値は `void` で、引数は先頭アドレスを意味する文字配列です。

---

### 実引数を「配列の先頭アドレス」とする関数func()の利用例として正しいものを選択してください。ただし，関数の利用前に以下の変数と配列の宣言があるとする。

```c
char c = '0', s[10] = {c, '\0'};
```

1. func( c );
2. func( s\[1] );
3. func( s\[0] );
4. func( s\[10] );
5. func( s );

**正解: 5**
解説: `func(char[])` のような関数に渡す場合、配列変数 `s` は先頭アドレスとして評価されるため `func(s);` が正解です。

---

### アドレス演算子として正しいものを選択しなさい。

1. \#
2. &
3. !
4. \*
5. @

**正解: 2**
解説: `&` はアドレス演算子で、変数のメモリアドレスを取得するときに使います。

---

### 間接演算子として正しいものを選択しなさい。

1. !
2. \*
3. @
4. \#
5. &

**正解: 2**
解説: `*` は間接演算子で、ポインタが指すアドレスの値を参照する際に使用します。

---

### int a=7, \*ptr = \&a;としたとき，printf("%d", \*ptr);の実行により画面に表示される内容として正しいものを選択しなさい。

1. 変数ptrに保存された値
2. 実行環境により異なる整数値
3. 変数ptrのアドレス
4. 変数aに保存された値
5. 変数aのアドレス

**正解: 4**
解説: `*ptr` は `ptr` が指すアドレス、つまり `a` の値を意味するため `7` が表示されます。

---

### double型配列x\[3]の基底アドレスとして正しい表現を選択しなさい。

1. x
2. \*x\[0]
3. \&x\[0]
4. x\[0]
5. \&x\[1]

**正解: 1, 3**
解説: 配列名 `x` は先頭アドレスを表します。`&x[0]` も同様に先頭要素のアドレスを指します。

## 10章
### int ary\[6] = {1,2,3,101,102,103};として宣言した配列aryの基底アドレスが100であったときに，printf("%u", \&ary\[1]);の実行により画面に表示される値として正しいものを選択しなさい。

1. 104
2. 103
3. 101
4. 1
5. 4

**正解: 1**
解説: `&ary[1]` は `ary[0]` の次の要素のアドレスを意味します。`int` は4バイトなので、`100 + 4 = 104` となります。

---

### 配列int a\[6]の要素番号4の値を表すものを選択しなさい。

1. \*(\&a\[3]+1)
2. a\[4]
3. \*a+4
4. \*(a+4)
5. a+4

**正解: 1, 2, 4**
解説: `a[4]` は直接的な指定、`*(a+4)` はポインタとしての演算、`*(&a[3]+1)` はアドレス計算を用いた間接参照。いずれも同じ要素 `a[4]` を指します。

## 12章
### int型の変数x, yで構成される構造体xydataの記述として正しいものを選択しなさい。

1. struct {
   int x; int y;
   } xydata;
2. struct xydata {
   int x, y;
   };
3. struct xydata {
   int x; int y;
   };
4. struct xydata {
   int x, y;
   }
5. struct xydata {
   int x; int y;
   }

**正解: 2, 3**
解説: 構造体定義の正しい形式は `struct xydata { int x; int y; };` または `int x, y;` のように変数をカンマで区切って定義しても構いません。末尾にセミコロンが必要です。

---

### 4π/3 の計算をPI4o3という名前でマクロ定義したい。記述として正しいものを選択しなさい。ただし，プログラムの先頭に#include の記述があるものとする。

1. \#include PI4o3 M\_PI\*4.0/3.0
2. \#define PI4o3 M\_PI\*4.0/3.0
3. \#define PI4o3 (4/3\*M\_PI)
4. \#define PI4o3 (M\_PI\*4.0/3.0)
5. \#define PI4o3 4/3\*M\_PI

**正解: 4**
解説: マクロ定義では演算順を明確にするため括弧を使用するのが推奨されます。浮動小数点で正確に計算するには `4.0/3.0` を使い、`(M_PI*4.0/3.0)` が正しい形式です。

---

### n³の計算をCUBE(n)という名前でマクロ定義したい。記述として正しいものを選択しなさい。

1. \#define CUBE(n) n*n*n
2. \#define CUBE(n) (n)*(n)*(n)
3. \#define CUBE(n) ((n)*(n)*(n))
4. \#define CUBE(n) n^3
5. \#define CUBE(n) (n*n*n)

**正解: 3**
解説: マクロ展開時に副作用を防ぐためには引数全体を括弧で囲うことが重要です。`((n)*(n)*(n))` が正しい安全な形式です。
